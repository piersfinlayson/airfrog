// Copyright (C) 2025 Piers Finlayson <piers@piers.rocks>
//
// MIT License

//! airfrog - Config types

use alloc::format;
use alloc::string::String;
use alloc::vec;
use alloc::vec::Vec;
use core::fmt::Debug;
use core::mem::{offset_of, size_of};
use embassy_net::{Config as NetConfig, Ipv4Address, Ipv4Cidr, StaticConfigV4};
use embassy_sync::blocking_mutex::raw::CriticalSectionRawMutex;
use embassy_sync::mutex::Mutex;
use embassy_sync::once_lock::OnceLock;
use esp_bootloader_esp_idf::partitions::{DataPartitionSubType, PartitionType};
use heapless::Vec as HeaplessVec;
#[allow(unused_imports)]
use log::{debug, error, info, trace, warn};
use static_assertions::{const_assert, const_assert_eq};

use airfrog_swd::protocol::Speed;
use airfrog_util::net::InterfaceConfig;

use crate::CONFIG_STORE_SIGNAL;
use crate::device::Device;
use crate::flash::CRC32;
use crate::target::Settings;

/// Non-volatile configuration for Airfrog.  Loaded from flash at startup.
/// Retrieve with `CONFIG.get().await.lock().await`.
pub static CONFIG: OnceLock<Mutex<CriticalSectionRawMutex, WrappedConfig>> = OnceLock::new();

/// Magic bytes at the start of Config
const MAGIC_BYTES: [u8; 4] = *b"Afrg";

/// Maximum size of an airfrog config
const CONFIG_PART_SIZE: usize = 0x400;

// FAT is 0x81
pub const CONFIG_PART_TYPE: PartitionType = PartitionType::Data(DataPartitionSubType::Fat);

const DEFAULT_AP_PASSWORD: &[u8] = b"airfrogx";

// Include partition information, auto-generated by build.rs
include!(concat!(env!("OUT_DIR"), "/partitions.rs"));

/// Internally used WiFi configuration struct.  Used to pass the WiFi
/// configuration to main in a form it can easily use.
#[derive(Debug, Clone)]
pub struct Wifi {
    pub mode: NetMode,
    pub sta_if: Option<InterfaceConfig>,
    pub ap_if: Option<InterfaceConfig>,
}

/// Wraps all of our config into a single type
#[derive(Debug, Clone)]
#[allow(unused)]
pub struct WrappedConfig {
    pub config: Config,
    pub net: Net,
    pub swd: Swd,
}

impl WrappedConfig {
    pub async fn update_flash(&self) {
        CONFIG_STORE_SIGNAL.signal(());
    }

    pub fn wifi_config(&self) -> Wifi {
        fn netmask_to_prefix(netmask: [u8; 4]) -> u8 {
            let mask = u32::from_be_bytes(netmask);
            mask.count_ones() as u8
        }

        fn create_static_config(
            ip: [u8; 4],
            netmask: [u8; 4],
            gateway: [u8; 4],
            dns: &[[u8; 4]],
        ) -> NetConfig {
            let mut dns_servers = HeaplessVec::<Ipv4Address, 3>::new();
            for &dns_ip in dns {
                if dns_ip != [0, 0, 0, 0] && dns_ip != [0xFF, 0xFF, 0xFF, 0xFF] {
                    let _ = dns_servers
                        .push(Ipv4Address::new(dns_ip[0], dns_ip[1], dns_ip[2], dns_ip[3]));
                }
            }

            NetConfig::ipv4_static(StaticConfigV4 {
                address: Ipv4Cidr::new(
                    Ipv4Address::new(ip[0], ip[1], ip[2], ip[3]),
                    netmask_to_prefix(netmask),
                ),
                gateway: Some(Ipv4Address::new(
                    gateway[0], gateway[1], gateway[2], gateway[3],
                )),
                dns_servers,
            })
        }

        let sta_if = self.net.sta_ssid().map(|ssid| {
            let net = if self.net.sta_v4_dhcp() {
                NetConfig::dhcpv4(Default::default())
            } else {
                create_static_config(
                    self.net.sta_v4_ip(),
                    self.net.sta_v4_netmask(),
                    self.net.sta_v4_gw(),
                    &[self.net.sta_v4_dns0(), self.net.sta_v4_dns1()],
                )
            };

            InterfaceConfig {
                ssid,
                password: self.net.sta_password().unwrap_or_default(),
                net,
            }
        });

        let ap_if = self.net.ap_ssid().map(|ssid| {
            let net = create_static_config(
                self.net.ap_v4_ip(),
                self.net.ap_v4_netmask(),
                self.net.ap_v4_ip(),
                &[],
            );

            InterfaceConfig {
                ssid,
                password: self.net.ap_password().unwrap_or_default(),
                net,
            }
        });

        Wifi {
            mode: self.net.mode,
            sta_if,
            ap_if,
        }
    }
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct Header {
    // Magic bytes to identify the config partition as valid
    magic: [u8; 4],

    // Size of config space - starting from the beginning of this struct
    size: u32,

    // Covers the CRC32 checksum of size - 12 (magic, size, crc values)
    crc: u32,

    // Config instance - 0 or 1
    instance: u8,

    // Partition index
    partition_index: u8,

    // Padding
    pad: [u8; 2],

    /// Version information
    major_version: u16,
    minor_version: u16,
    patch_version: u16,
    build_version: u16,
}

impl Header {
    const CRC_FROM: usize = offset_of!(Header, instance);
    const CRC_OFFSET: usize = offset_of!(Header, crc);
}

impl Default for Header {
    fn default() -> Self {
        // Sanity checking various consts
        const_assert!((PART_SIZE_AIRFROG_CONF_0 as usize) >= CONFIG_PART_SIZE);
        const_assert_eq!(PART_SIZE_AIRFROG_CONF_0, PART_SIZE_AIRFROG_CONF_1);
        const_assert!(Config::OFFSET == 0);
        const_assert!(Net::OFFSET >= size_of::<Config>());
        const_assert!(Swd::OFFSET >= size_of::<Net>() + size_of::<Config>());
        const_assert!(Config::OFFSET.is_multiple_of(4));
        const_assert!(Net::OFFSET.is_multiple_of(4));
        const_assert!(Swd::OFFSET.is_multiple_of(4));
        const_assert!(PART_INDEX_AIRFROG_CONF_0 < u8::MAX as usize);

        let major_version = crate::PKG_VERSION_MAJOR.parse().unwrap_or(0xFFFF);
        let minor_version = crate::PKG_VERSION_MINOR.parse().unwrap_or(0xFFFF);
        let patch_version = crate::PKG_VERSION_PATCH.parse().unwrap_or(0xFFFF);
        Self {
            magic: MAGIC_BYTES,
            size: CONFIG_PART_SIZE as u32,
            crc: 0,
            instance: 0,
            partition_index: PART_INDEX_AIRFROG_CONF_0 as u8,
            pad: [0xFF; 2],
            major_version,
            minor_version,
            patch_version,
            build_version: 0,
        }
    }
}

/// Top-level Airfrog configuration
///
/// Located on flash at 0x9000
///
/// 64 bytes
#[repr(C)]
#[derive(Clone, Copy)]
pub struct Config {
    /// Header
    /// 24 bytes
    header: Header,

    // Net offset
    net_offset: u32,

    // Swd offset
    swd_offset: u32,

    /// Reserved for future use
    reserved: [u8; 32],
}

impl Debug for Config {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_struct("Config")
            .field("header", &self.header)
            .field("net_offset", &self.net_offset)
            .field("swd_offset", &self.swd_offset)
            .finish()
    }
}

impl Config {
    const OFFSET: usize = 0;

    pub fn from_bytes(bytes: &[u8]) -> Self {
        get_struct_from_slice(bytes)
    }
}

impl Default for Config {
    fn default() -> Self {
        Self {
            header: Header::default(),
            net_offset: Net::OFFSET as u32,
            swd_offset: Swd::OFFSET as u32,
            reserved: [0xFF; 32],
        }
    }
}

#[repr(u32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
#[allow(unused)]
pub enum NetMode {
    #[default]
    StaFallbackToAp = 0,
    ApOnly = 1,
}

impl NetMode {
    pub fn is_sta(&self) -> bool {
        match self {
            NetMode::StaFallbackToAp => true,
            NetMode::ApOnly => false,
        }
    }

    pub fn is_ap(&self) -> bool {
        match self {
            NetMode::StaFallbackToAp => true,
            NetMode::ApOnly => true,
        }
    }
}

/// Network configuration
///
/// 512 bytes
#[repr(C)]
#[derive(Clone, Copy)]
pub struct Net {
    mode: NetMode,

    /// SSID when used as a station
    sta_ssid: [u8; 32],

    /// Password when used as a station
    sta_password: [u8; 64],

    // Indicates whether DHCP is enabled for the station interface
    sta_v4_dhcp: u8,
    pad0: [u8; 3],

    sta_v4_ip: [u8; 4],
    sta_v4_netmask: [u8; 4],
    sta_v4_gw: [u8; 4],
    sta_v4_dns0: [u8; 4],
    sta_v4_dns1: [u8; 4],
    sta_v4_ntp: [u8; 4],

    /// SSID when used as an access point
    ap_ssid: [u8; 32],

    /// Password when used as an access point
    ap_password: [u8; 64],

    ap_v4_ip: [u8; 4],
    ap_v4_netmask: [u8; 4],
}

impl Debug for Net {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_struct("Net")
            .field("mode", &self.mode)
            .field("sta_ssid", &self.sta_ssid)
            .field("sta_v4_dhcp", &self.sta_v4_dhcp)
            .field("sta_v4_ip", &self.sta_v4_ip)
            .field("sta_v4_netmask", &self.sta_v4_netmask)
            .field("sta_v4_gw", &self.sta_v4_gw)
            .field("sta_v4_dns0", &self.sta_v4_dns0)
            .field("sta_v4_dns1", &self.sta_v4_dns1)
            .field("sta_v4_ntp", &self.sta_v4_ntp)
            .field("ap_ssid", &self.ap_ssid)
            .field("ap_v4_ip", &self.ap_v4_ip)
            .field("ap_v4_netmask", &self.ap_v4_netmask)
            .finish()
    }
}

impl Net {
    const OFFSET: usize = Config::OFFSET + size_of::<Config>();

    pub fn from_bytes(bytes: &[u8]) -> Self {
        get_struct_from_slice(bytes)
    }

    fn get_string(bytes: &[u8]) -> Option<String> {
        // Convert the byte array to a string, trimming trailing 0xFF and null bytes
        let trimmed = bytes
            .iter()
            .take_while(|&&b| b != 0xFF && b != 0)
            .cloned()
            .collect::<Vec<_>>();
        String::from_utf8(trimmed).map(Some).unwrap_or_else(|_| {
            warn!("Invalid UTF-8 in string");
            None
        })
    }

    pub fn sta_ssid(&self) -> Option<String> {
        Self::get_string(&self.sta_ssid)
    }

    pub fn sta_password(&self) -> Option<String> {
        Self::get_string(&self.sta_password)
    }

    pub fn ap_ssid(&self) -> Option<String> {
        Self::get_string(&self.ap_ssid)
    }

    pub fn ap_password(&self) -> Option<String> {
        let pass = Self::get_string(&self.ap_password);
        if let Some(pass) = pass {
            // Ensure the password is at least 8 characters long
            if pass.len() < 8 {
                // Pad with the required number of 'x's if it's too short
                error!("Error: AP password is too short - padding with 'x' to 8 chars");
                let padding = "x".repeat(8 - pass.len());
                Some(format!("{pass}{padding}"))
            } else {
                Some(pass)
            }
        } else {
            pass
        }
    }

    pub fn mode(&self) -> NetMode {
        self.mode
    }

    pub fn sta_v4_dhcp(&self) -> bool {
        self.sta_v4_dhcp == 1
    }

    pub fn sta_v4_ip(&self) -> [u8; 4] {
        self.sta_v4_ip
    }

    pub fn sta_v4_netmask(&self) -> [u8; 4] {
        self.sta_v4_netmask
    }

    pub fn sta_v4_gw(&self) -> [u8; 4] {
        self.sta_v4_gw
    }

    pub fn sta_v4_dns0(&self) -> [u8; 4] {
        self.sta_v4_dns0
    }

    pub fn sta_v4_dns1(&self) -> [u8; 4] {
        self.sta_v4_dns1
    }

    pub fn sta_v4_ntp(&self) -> [u8; 4] {
        self.sta_v4_ntp
    }

    pub fn ap_v4_ip(&self) -> [u8; 4] {
        self.ap_v4_ip
    }

    pub fn ap_v4_netmask(&self) -> [u8; 4] {
        self.ap_v4_netmask
    }

    pub fn deserialize(value: serde_json::Value) -> Option<Self> {
        let obj = value.as_object()?;

        // Parse mode
        let mode = match obj.get("mode")?.as_str()? {
            "StaFallbackToAp" => NetMode::StaFallbackToAp,
            "ApOnly" => NetMode::ApOnly,
            _ => return None,
        };

        // Helper to convert string to byte array with 0xFF padding
        let string_to_bytes = |s: &str, size: usize| -> Vec<u8> {
            let mut bytes = vec![0xFF; size];
            let str_bytes = s.as_bytes();
            let copy_len = str_bytes.len().min(size);
            bytes[..copy_len].copy_from_slice(&str_bytes[..copy_len]);
            bytes
        };

        // Helper to parse IP array
        let parse_ip = |key: &str| -> Option<[u8; 4]> {
            let arr = obj.get(key)?.as_array()?;
            if arr.len() != 4 {
                info!(
                    "Error: Invalid IP array length for {key}: expected 4, got {}",
                    arr.len()
                );
                return None;
            }
            let mut ip = [0u8; 4];
            for (i, val) in arr.iter().enumerate() {
                let num = val.as_u64()?;
                if num > 255 {
                    info!("Error: Invalid IP value for {key}: {num}");
                    return None;
                }
                ip[i] = num as u8;
            }
            Some(ip)
        };

        // Helper to check netmask
        let parse_netmask = |key: &str, class_c: bool| -> Option<[u8; 4]> {
            let ip = parse_ip(key)?;
            if class_c && ip[3] != 0 {
                info!("Error: Invalid Class C netmask for {key}: {ip:?}");
                return None;
            }

            // Convert to u32 and check if it's a valid netmask
            let mask = u32::from_be_bytes(ip);
            let inverted = !mask;

            // Valid netmask: inverted + 1 should be a power of 2 (or 0 for /0)
            if inverted != 0 && (inverted + 1) & inverted != 0 {
                info!("Error: Invalid netmask for {key}: {ip:?}");
                return None;
            }

            Some(ip)
        };

        // Parse strings
        let sta_ssid_str = obj.get("sta_ssid")?.as_str()?;
        let sta_password_str = obj.get("sta_password")?.as_str()?;
        let ap_ssid_str = obj.get("ap_ssid")?.as_str()?;
        let ap_password_str = obj.get("ap_password")?.as_str()?;
        if ap_password_str.len() < 8 {
            info!("Error: AP password is too short - must be at least 8 characters");
            return None;
        }

        // Convert to byte arrays
        let sta_ssid_bytes = string_to_bytes(sta_ssid_str, 32);
        let sta_password_bytes = string_to_bytes(sta_password_str, 64);
        let ap_ssid_bytes = string_to_bytes(ap_ssid_str, 32);
        let ap_password_bytes = string_to_bytes(ap_password_str, 64);

        // Parse DHCP
        let sta_v4_dhcp = if obj.get("sta_v4_dhcp")?.as_bool()? {
            1
        } else {
            0
        };

        // Parse IP addresses
        let sta_v4_ip = parse_ip("sta_v4_ip")?;
        let sta_v4_netmask = parse_netmask("sta_v4_netmask", false)?;

        let sta_v4_gw = parse_ip("sta_v4_gw")?;
        let sta_v4_dns0 = parse_ip("sta_v4_dns0")?;
        let sta_v4_dns1 = parse_ip("sta_v4_dns1")?;
        let sta_v4_ntp = parse_ip("sta_v4_ntp")?;
        let ap_v4_ip = parse_ip("ap_v4_ip")?;
        let ap_v4_netmask = parse_netmask("ap_v4_netmask", true)?;

        Some(Self {
            mode,
            sta_ssid: sta_ssid_bytes.try_into().ok()?,
            sta_password: sta_password_bytes.try_into().ok()?,
            sta_v4_dhcp,
            sta_v4_ip,
            sta_v4_netmask,
            sta_v4_gw,
            sta_v4_dns0,
            sta_v4_dns1,
            sta_v4_ntp,
            ap_ssid: ap_ssid_bytes.try_into().ok()?,
            ap_password: ap_password_bytes.try_into().ok()?,
            ap_v4_ip,
            ap_v4_netmask,
            ..Default::default()
        })
    }

    pub fn serialize(&self) -> serde_json::Value {
        // Helper to convert IP to array
        let ip_to_array = |ip: &[u8; 4]| -> serde_json::Value {
            serde_json::Value::Array(ip.iter().map(|&b| serde_json::Value::from(b)).collect())
        };

        // Convert mode to string
        let mode_str = match self.mode {
            NetMode::StaFallbackToAp => "StaFallbackToAp",
            NetMode::ApOnly => "ApOnly",
        };

        serde_json::json!({
            "mode": mode_str,
            "sta_ssid": self.sta_ssid().unwrap_or_default(),
            "sta_password": self.sta_password().unwrap_or_default(),
            "sta_v4_dhcp": self.sta_v4_dhcp == 1,
            "sta_v4_ip": ip_to_array(&self.sta_v4_ip),
            "sta_v4_netmask": ip_to_array(&self.sta_v4_netmask),
            "sta_v4_gw": ip_to_array(&self.sta_v4_gw),
            "sta_v4_dns0": ip_to_array(&self.sta_v4_dns0),
            "sta_v4_dns1": ip_to_array(&self.sta_v4_dns1),
            "sta_v4_ntp": ip_to_array(&self.sta_v4_ntp),
            "ap_ssid": Self::get_string(&self.ap_ssid).unwrap_or_default(),
            "ap_password": Self::get_string(&self.ap_password).unwrap_or_default(),
            "ap_v4_ip": ip_to_array(&self.ap_v4_ip),
            "ap_v4_netmask": ip_to_array(&self.ap_v4_netmask)
        })
    }
}

impl Default for Net {
    fn default() -> Self {
        #[cfg(feature = "wifi-sta")]
        let (sta_ssid, sta_password) = {
            let ssid_bytes = env!("AF_STA_SSID").as_bytes();
            let pass_bytes = env!("AF_STA_PASSWORD").as_bytes();

            let mut ssid = [0xFF; 32];
            let mut password = [0xFF; 64];

            ssid[..ssid_bytes.len().min(32)]
                .copy_from_slice(&ssid_bytes[..ssid_bytes.len().min(32)]);
            password[..pass_bytes.len().min(64)]
                .copy_from_slice(&pass_bytes[..pass_bytes.len().min(64)]);

            (ssid, password)
        };
        #[cfg(not(feature = "wifi-sta"))]
        let (sta_ssid, sta_password) = ([0xFF; 32], [0xFF; 64]);

        // Get default AP SSID and password
        let mac = Device::mac_address();
        let ap_ssid_str = format!("airfrog-{:02x}{:02x}", mac[4], mac[5]);
        let mut ap_ssid = [0xFF; 32];
        let bytes = ap_ssid_str.as_bytes();
        ap_ssid[..bytes.len()].copy_from_slice(bytes);

        let ap_password = {
            let mut pass = [0xFF; 64];
            let default_pass = DEFAULT_AP_PASSWORD;
            pass[..default_pass.len()].copy_from_slice(default_pass);
            pass
        };

        Self {
            mode: NetMode::default(),

            // Station config - empty/unset
            sta_ssid,
            sta_password,
            sta_v4_dhcp: 1, // DHCP enabled
            pad0: [0; 3],

            // Station IP config - unset (will use DHCP)
            sta_v4_ip: [0xFF; 4],
            sta_v4_netmask: [0xFF; 4],
            sta_v4_gw: [0xFF; 4],
            sta_v4_dns0: [0xFF; 4],
            sta_v4_dns1: [0xFF; 4],
            sta_v4_ntp: [0xFF; 4],

            // AP config - sensible defaults
            ap_ssid,
            ap_password,

            // AP IP config - 192.168.4.1/24 (ESP32 default)
            ap_v4_ip: [192, 168, 4, 1],
            ap_v4_netmask: [255, 255, 255, 0],
        }
    }
}

/// Supported SWD speeds
#[repr(u32)]
#[derive(Debug, Clone, Copy, Default)]
#[allow(unused)]
pub enum SwdSpeed {
    #[default]
    Turbo = 0,
    Fast = 1,
    Medium = 2,
    Slow = 3,
}

impl From<SwdSpeed> for Speed {
    fn from(speed: SwdSpeed) -> Self {
        match speed {
            SwdSpeed::Turbo => Speed::Turbo,
            SwdSpeed::Fast => Speed::Fast,
            SwdSpeed::Medium => Speed::Medium,
            SwdSpeed::Slow => Speed::Slow,
        }
    }
}

impl From<Speed> for SwdSpeed {
    fn from(speed: Speed) -> Self {
        match speed {
            Speed::Turbo => SwdSpeed::Turbo,
            Speed::Fast => SwdSpeed::Fast,
            Speed::Medium => SwdSpeed::Medium,
            Speed::Slow => SwdSpeed::Slow,
        }
    }
}

impl From<Swd> for Settings {
    fn from(swd: Swd) -> Self {
        Self {
            speed: swd.speed.into(),
            auto_connect: swd.auto_connect == 1,
            keepalive: swd.keep_alive == 1,
            refresh: swd.refresh == 1,
        }
    }
}

impl From<Settings> for Swd {
    fn from(settings: Settings) -> Self {
        Swd {
            speed: settings.speed.into(),
            auto_connect: if settings.auto_connect { 1 } else { 0 },
            keep_alive: if settings.keepalive { 1 } else { 0 },
            refresh: if settings.refresh { 1 } else { 0 },
            ..Default::default()
        }
    }
}

/// SWD configuration
///
/// 64 bytes
#[repr(C)]
#[derive(Clone, Copy)]
pub struct Swd {
    pub speed: SwdSpeed,

    /// Whether auto connect is enabled
    pub auto_connect: u8,

    /// Whether keep-alive is enabled
    pub keep_alive: u8,

    /// Whether firmware refresh is enabled
    pub refresh: u8,

    pad0: u8,
}

impl Debug for Swd {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_struct("Swd")
            .field("speed", &self.speed)
            .field("auto_connect", &self.auto_connect)
            .field("keep_alive", &self.keep_alive)
            .field("refresh", &self.refresh)
            .finish()
    }
}

impl Swd {
    const OFFSET: usize = Net::OFFSET + size_of::<Net>();

    pub fn from_bytes(bytes: &[u8]) -> Self {
        get_struct_from_slice(bytes)
    }
}

impl Default for Swd {
    fn default() -> Self {
        Self {
            speed: SwdSpeed::default(),
            auto_connect: 1,
            keep_alive: 1,
            refresh: 1,
            pad0: 0,
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Error {
    Magic,
    Size,
    Crc,
    Instance,
    PartitionIndex,
    Offset,
}

// Used to copy config structs to a buf
fn copy_struct_to_slice<T>(dst: &mut [u8], value: T) {
    let bytes = unsafe {
        core::slice::from_raw_parts(&value as *const _ as *const u8, core::mem::size_of::<T>())
    };
    dst[..bytes.len()].copy_from_slice(bytes);
}

fn copy_config_to_slice(dst: &mut [u8], config: &Config) {
    copy_struct_to_slice(dst, *config);
}

fn copy_net_to_slice(dst: &mut [u8], net: &Net) {
    copy_struct_to_slice(dst, *net);
}

fn copy_swd_to_slice(dst: &mut [u8], swd: &Swd) {
    copy_struct_to_slice(dst, *swd);
}

// Gets the config struct from an array of bytes (array to allow compile time
// size checking)
fn get_struct_from_slice<T>(src: &[u8]) -> T
where
    T: Clone,
{
    assert!(src.len() >= size_of::<T>());
    assert!((src.as_ptr() as usize).is_multiple_of(4));
    let object = unsafe { &*(src.as_ptr() as *const T) };
    object.clone()
}

/// Use to create the entire config partition in the provided buf using the
/// provided config structs
pub fn build_config_partition(
    buf: &mut [u8; CONFIG_PART_SIZE],
    config: &mut Config,
    net: &Net,
    swd: &Swd,
) {
    // Initialize buf to 0xFF
    *buf = [0xFFu8; CONFIG_PART_SIZE];

    config.net_offset = Net::OFFSET as u32;
    config.swd_offset = Swd::OFFSET as u32;

    // Copy in each struct
    copy_config_to_slice(&mut buf[Config::OFFSET..], config);
    copy_net_to_slice(&mut buf[Net::OFFSET..], net);
    copy_swd_to_slice(&mut buf[Swd::OFFSET..], swd);

    // Update the CRC
    config.header.crc = calc_crc(buf);
    update_buf_crc(buf, config.header.crc);
}

/// Use to create a new config partition in the provided buf
pub fn new_config_partition_default(
    instance: u8,
    partition_index: u8,
    buf: &mut [u8; CONFIG_PART_SIZE],
) {
    // Create the default configuration
    let mut config = Config::default();
    config.header.instance = instance;
    config.header.partition_index = partition_index;

    let net = Net::default();
    let swd = Swd::default();

    // Now build it
    build_config_partition(buf, &mut config, &net, &swd);
}

// Calculate the CRC checksum of the provided config partition
fn calc_crc(buf: &[u8; CONFIG_PART_SIZE]) -> u32 {
    CRC32.checksum(&buf[Header::CRC_FROM..])
}

/// Create static config objects from the provided partition.
///
/// Must only be called once or will panic.
pub fn create_static_config(buf: &[u8; CONFIG_PART_SIZE]) -> Result<(), Error> {
    // Check the config partition
    check_config_partition(buf)?;

    // Create the config object
    let config = Config::from_bytes(&buf[0..size_of::<Config>()]);
    let net_offset = config.net_offset as usize;
    let net = Net::from_bytes(&buf[net_offset..net_offset + size_of::<Net>()]);
    let swd_offset = config.swd_offset as usize;
    let swd = Swd::from_bytes(&buf[swd_offset..swd_offset + size_of::<Swd>()]);

    // Now create a static using a Wrapped object
    let wrapped = WrappedConfig { config, net, swd };

    CONFIG
        .init(Mutex::<CriticalSectionRawMutex, WrappedConfig>::new(
            wrapped,
        ))
        .expect("CONFIG already initialized");

    Ok(())
}

// Checks whether the config partition CRC is valid
fn check_config_partition(buf: &[u8; CONFIG_PART_SIZE]) -> Result<(), Error> {
    const_assert!(CONFIG_PART_SIZE >= size_of::<Config>());
    let config: Config = get_struct_from_slice(buf);

    // Check the magic bytes
    if config.header.magic != MAGIC_BYTES {
        warn!(
            "Invalid magic bytes in config partition {:?}",
            config.header.magic
        );
        return Err(Error::Magic);
    }

    // Check its size
    if config.header.size != CONFIG_PART_SIZE as u32 {
        warn!(
            "Invalid size in config partition: expected {}, got {}",
            CONFIG_PART_SIZE, config.header.size
        );
        return Err(Error::Size);
    }

    // Check its CRC
    let cur_crc = config.header.crc;
    let calc_crc = calc_crc(buf);
    if cur_crc != calc_crc {
        warn!("Invalid CRC32 in config partition: expected {calc_crc:#010X}, got {cur_crc:#010X}",);
        return Err(Error::Crc);
    }

    // Check instance
    if config.header.instance != 0 && config.header.instance != 1 {
        warn!(
            "Invalid instance in config partition: got {}",
            config.header.instance
        );
        return Err(Error::Instance);
    }

    // Check partition index
    if config.header.partition_index >= PART_COUNT as u8 {
        warn!(
            "Invalid partition index in config partition: got {}",
            config.header.partition_index
        );
        return Err(Error::PartitionIndex);
    }

    // Check offsets
    if config.net_offset != Net::OFFSET as u32 {
        warn!(
            "Invalid net offset in config partition: expected {}, got {}",
            Net::OFFSET,
            config.net_offset
        );
        return Err(Error::Offset);
    }
    if config.swd_offset != Swd::OFFSET as u32 {
        warn!(
            "Invalid swd offset in config partition: expected {}, got {}",
            Swd::OFFSET,
            config.swd_offset
        );
        return Err(Error::Offset);
    }

    Ok(())
}

// Update the checksum CRC in the partition buffer
fn update_buf_crc(buf: &mut [u8; CONFIG_PART_SIZE], crc: u32) {
    buf[Header::CRC_OFFSET..Header::CRC_OFFSET + 4].copy_from_slice(&crc.to_le_bytes());
}

pub const fn config_partition_size() -> usize {
    CONFIG_PART_SIZE
}
