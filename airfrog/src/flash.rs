// Copyright (C) 2025 Piers Finlayson <piers@piers.rocks>
//
// MIT License

//! airfrog - Flash storage objects

use crc::{CRC_32_ISO_HDLC, Crc};
use embedded_storage::{ReadStorage, Storage};
use esp_bootloader_esp_idf::partitions;
use esp_bootloader_esp_idf::partitions::{
    DataPartitionSubType, PartitionEntry, PartitionTable, PartitionType,
};
use esp_storage::FlashStorage;
#[allow(unused_imports)]
use log::{debug, error, info, trace, warn};

use crate::config::CONFIG;
use crate::config::CONFIG_PART_TYPE;
use crate::config::Error as ConfigError;
use crate::config::{
    build_config_partition, config_partition_size, create_static_config,
    new_config_partition_default,
};
use crate::device::DEVICE;
use crate::{AirfrogError, ErrorKind};

// Include partition information, auto-generated by build.rs
include!(concat!(env!("OUT_DIR"), "/partitions.rs"));

// Type for CRC checking
pub const CRC32: Crc<u32> = Crc::<u32>::new(&CRC_32_ISO_HDLC);

// Spiffs is 0x82
pub const _DATA_PART_TYPE: PartitionType = PartitionType::Data(DataPartitionSubType::Spiffs);

// Use 4 byte aligned buffers, so we can cast the data to config structs
#[repr(align(4))]
struct AlignedBuf<const N: usize>([u8; N]);

// Errors that can occur while working with flash storage
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum Error {
    BadPartitionTable,
    InvalidConfig,
    InvalidPartition,
    FlashStorage,
}

impl From<Error> for AirfrogError {
    fn from(_: Error) -> Self {
        AirfrogError::Airfrog(ErrorKind::Flash)
    }
}

impl From<ConfigError> for Error {
    fn from(_: ConfigError) -> Self {
        Error::InvalidConfig
    }
}

/// Object for working with flash storage
pub struct Flash {
    storage: FlashStorage,
}

impl Flash {
    pub async fn new() -> Self {
        // Sanity checking
        let flash = Flash {
            storage: FlashStorage::new(),
        };
        info!("Info:  Flash size = {}", flash.capacity());
        DEVICE
            .get()
            .await
            .lock()
            .await
            .set_flash_size(flash.capacity());
        flash
    }

    pub fn capacity(&self) -> usize {
        self.storage.capacity()
    }

    /// Loads config from flash.  If it fails, it will create a new config for
    /// use this time, and also attempt to store it on flash.
    pub fn load_config(&mut self) {
        read_config(&mut self.storage)
            .inspect_err(|e| {
                warn!("Failed to read/store config: {e:?}");
            })
            .ok();
    }

    /// Stores the current config to flash.
    pub async fn store_config(&mut self) {
        store_config(&mut self.storage)
            .await
            .inspect_err(|e| {
                warn!("Failed to store config: {e:?}");
            })
            .ok();
    }
}

async fn store_config(storage: &mut FlashStorage) -> Result<(), Error> {
    // Get the config
    let mut config = CONFIG.get().await.lock().await;

    // Create the partition entry for the new config
    let mut buf = AlignedBuf([0u8; config_partition_size()]);
    let net = config.net;
    let swd = config.swd;
    build_config_partition(&mut buf.0, &mut config.config, &net, &swd);

    // Read the current partition
    let mut current_buf = AlignedBuf([0u8; config_partition_size()]);
    read_from_partition(
        storage,
        PART_INDEX_AIRFROG_CONF_0,
        0,
        CONFIG_PART_TYPE,
        &mut current_buf.0,
    )
    .inspect_err(|e| warn!("Failed to read current config from flash: {e:?}"))?;

    // Compare the current config with the new one
    if current_buf.0 == buf.0 {
        warn!("Info:  Config unchanged, not writing to flash");
        return Ok(());
    }

    // Store the new config
    write_to_partition(
        storage,
        PART_INDEX_AIRFROG_CONF_0,
        0,
        CONFIG_PART_TYPE,
        &buf.0,
    )
    .inspect(|_| info!("OK:    Wrote config to flash"))
    .inspect_err(|e| {
        warn!("Failed to write default config to flash: {e:?}");
    })
}

fn get_partition_table<'a>(
    storage: &mut FlashStorage,
    pt_buf: &'a mut [u8],
) -> Result<PartitionTable<'a>, Error> {
    let pt = partitions::read_partition_table(storage, pt_buf)
        .inspect_err(|e| warn!("Failed to read partition table: {e:?}"))
        .map_err(|_| Error::BadPartitionTable)?;

    // Log the partitions
    for i in 0..pt.len() {
        let raw = pt.get_partition(i).unwrap();
        trace!("Partition: {raw:?}");
    }

    Ok(pt)
}

fn get_partition_entry<'a>(
    storage: &mut FlashStorage,
    pt_buf: &'a mut [u8],
    index: usize,
    required_len: u32,
    p_type: PartitionType,
) -> Result<PartitionEntry<'a>, Error> {
    let pt = get_partition_table(storage, pt_buf)?;

    let part = pt
        .get_partition(index)
        .inspect_err(|e| warn!("Failed to get partition {index}: {e:?}"))
        .map_err(|_| Error::InvalidPartition)?;

    if part.partition_type() != p_type {
        warn!(
            "Unexpected partition type for index {index}: {:?}",
            part.partition_type()
        );
        return Err(Error::InvalidPartition);
    }

    if part.len() < required_len {
        warn!(
            "Partition {index} is too small: {} < {required_len}",
            part.len(),
        );
        return Err(Error::InvalidPartition);
    }
    debug!(
        "Retrieved partition {index}: {} subtype {:#04X} offset {:#010X} len {:#X}",
        part.label_as_str(),
        part.raw_subtype(),
        part.offset(),
        part.len()
    );
    Ok(part)
}

fn read_from_partition(
    storage: &mut FlashStorage,
    index: usize,
    offset: u32,
    p_type: PartitionType,
    buf: &mut [u8],
) -> Result<(), Error> {
    // Get the partition entry - doesn't strictly need to be aligned
    let mut pt_mem = AlignedBuf([0u8; partitions::PARTITION_TABLE_MAX_LEN]);
    let part = get_partition_entry(
        storage,
        &mut pt_mem.0,
        index,
        config_partition_size() as u32,
        p_type,
    )?;

    // Get a storage object to read from
    let mut storage = part.as_embedded_storage(storage);

    // Read in the requested data
    storage
        .read(offset, buf)
        .inspect_err(|e| warn!("Failed to read from partition {index}: {e:?}"))
        .map_err(|_| Error::FlashStorage)?;

    Ok(())
}

fn write_to_partition(
    storage: &mut FlashStorage,
    index: usize,
    offset: u32,
    p_type: PartitionType,
    buf: &[u8],
) -> Result<(), Error> {
    // Get the partition entry
    let mut pt_mem = [0u8; partitions::PARTITION_TABLE_MAX_LEN];
    let part = get_partition_entry(
        storage,
        &mut pt_mem,
        index,
        config_partition_size() as u32,
        p_type,
    )?;

    // Get a storage object to write to
    let mut storage = part.as_embedded_storage(storage);

    // Write the data
    storage
        .write(offset, buf)
        .inspect_err(|e| warn!("Failed to write to partition {index}: {e:?}"))
        .map_err(|_| Error::FlashStorage)?;

    Ok(())
}

fn read_config(storage: &mut FlashStorage) -> Result<(), Error> {
    let mut config0_buf = AlignedBuf([0u8; config_partition_size()]);

    let result = read_from_partition(
        storage,
        PART_INDEX_AIRFROG_CONF_0,
        0,
        CONFIG_PART_TYPE,
        &mut config0_buf.0,
    );

    if result.is_ok() {
        // Successfully read in the config from flash.  Check it and turn it
        // into a static
        info!("Info:  Successfully read config from flash");
        match create_static_config(&config0_buf.0) {
            Ok(()) => return Ok(()),
            Err(_) => warn!("Config from partition failed checks"),
        }
    } else {
        warn!(
            "Failed to read config from partition: {:?}",
            result.unwrap_err()
        );
    }

    // Either we failed to read in the config from flash, or it was in error,
    // so create a new one
    new_config_partition_default(0u8, PART_INDEX_AIRFROG_CONF_0 as u8, &mut config0_buf.0);

    // Try and write it.  If this fails there's not much we can do.  We'll log
    // and continue with the RAM config we created.
    write_to_partition(
        storage,
        PART_INDEX_AIRFROG_CONF_0,
        0,
        CONFIG_PART_TYPE,
        &config0_buf.0,
    )
    .inspect(|_| info!("Info:  Wrote default config to flash"))
    .inspect_err(|e| {
        warn!("Failed to write default config to flash: {e:?}");
    })
    .ok();

    // Now turn the config into a static.  This checks should not fail, as it
    // was created from defaults.
    create_static_config(&config0_buf.0).expect("Internal error - failed to create default config");

    Ok(())
}
